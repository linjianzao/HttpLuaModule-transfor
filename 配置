syntax = 语法   default = 默认值   context = 配置的地方
lua_use_default_type
syntax：lua_use_default_type on | off
default：on
context：http, server, location, location if
说明：
Specifies whether to use the MIME type specified by the default_type directive for the default value of the Content-Type response header. If you do not want a default Content-Type response header for your Lua request handlers, then turn this directive off.
指定MIME 的类型
扩展阅读：http://hi.baidu.com/tangzhonghai/item/0df26339f80b17f8de22219b


lua_code_cache
syntax：lua_code_cache on | off
default：on
context: http, server, location, location if
说明：
缓存 set_by_lua_file, content_by_lua_file, rewrite_by_lua_file, and access_by_lua_file, 的文件。
一般是开发的时候关闭， 线上开启，速度加快很多，如果没有关闭你修改代码得到的结果可能和你预期的不一样


lua_regex_cache_max_entries
syntax: lua_regex_cache_max_entries <num>
default: lua_regex_cache_max_entries 1024
context: http
说明：
指定正则编译的缓存的最大数量
会缓存 ngx.re.match, ngx.re.gmatch, ngx.re.sub, and ngx.re.gsub
默认缓存1024长度，如果超过的话就不会缓存



lua_regex_match_limit
syntax: lua_regex_match_limit <num>
default: lua_regex_match_limit 0
context: http
说明：
Specifies the "match limit" used by the PCRE library when executing the ngx.re API. To quote the PCRE manpage, "the limit ... has the effect of limiting the amount of backtracking that can take place."
When the limit is hit, the error string "pcre_exec() failed: -8" will be returned by the ngx.re API functions on the Lua land.
When setting the limit to 0, the default "match limit" when compiling the PCRE library is used. And this is the default value of this directive.
当执行 ngx.re API 时指定使用PCRE库的匹配限制。
如果达到匹配限制，ngx.re API会返回-8
设为0时，匹配限制就是PCRE库的限制



lua_package_path
syntax: lua_package_path <lua-style-path-str>
default: The content of LUA_PATH environ variable or Lua's compiled-in defaults.
context: http
设置lua模块搜索的路径。  就是包含了模块文件就可以直接 用require “模块名”



lua_package_cpath
syntax: lua_package_cpath <lua-style-cpath-str>
default: The content of LUA_CPATH environment variable or Lua's compiled-in defaults.
context: http
设置lua C 模块的搜索路径



init_by_lua
syntax: init_by_lua <lua-script-str>
context: http
phase: loading-config
说明：
Nginx主进程load lua配置的时候，就可以在lua虚拟机的层面执行
nginx接到 HUP 信号， 重新load配置文件的时候 lua 虚拟机会重建，init_by_lua会在新的虚拟机执行
通常你可以在lua环境变量或者在服务启动时预加载。例子：
 init_by_lua 'cjson = require "cjson"';

  server {
      location = /api {
          content_by_lua '
              ngx.say(cjson.encode({dog = 5, cat = 6}))
          ';
      }
  }

在这个阶段你也可以初始化 lua_shared_dict 的存储，例子：
    lua_shared_dict dogs 1m;
 
    init_by_lua '
        local dogs = ngx.shared.dogs;
        dogs:set("Tom", 56)
    ';
 
    server {
        location = /api {
            content_by_lua '
                local dogs = ngx.shared.dogs;
                ngx.say(dogs:get("Tom"))
            ';
        }
    }
但是使用lua_shared_dict 在配置被重新载入的时候是不会被清除的。
所以在这个例子里，如果你不想在你的 init_by_lua 代码里重新初始化shm存储，
你必须定义一个标示，然后在init_by_lua 代码里检查标示。
其他详细说明看文档。


init_by_lua_file
syntax: init_by_lua_file <path-to-lua-script-file>
context: http
phase: loading-config
说明： 和 init_by_lua 差不多，除了指定的文件<path-to-lua-script-file>包含lua代码或Lua的/ LuaJIT字节码的执行。
当给 foo/bar.lua 的时候， 会转为绝对路径。可以在服务器启动的时候使用-p 来相对




set_by_lua
syntax: set_by_lua $res <lua-script-str> [$arg1 $arg2 ...]
context: server, server if, location, location if
phase: server-rewrite, rewrite
说明：
使用参数 执行 在<lua-script-str> 指定的代码，返回string 结果到$res
<lua-script-str> 的代码可以使用API 调用，然后使用 ngx.arg 接收结果，索引从1开始
这个指令是设计用来执行短、快的代码的，应该避免耗时的代码
不能在这里使用的API函数：
 Output API functions (e.g., ngx.say and ngx.send_headers)
 Control API functions (e.g., ngx.exit)
 Subrequest API functions (e.g., ngx.location.capture and ngx.location.capture_multi)
 Cosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).
此外，这个指令一次只能返回一个nginx变量值，替代的解决方法时  ngx.var.VARIABLE 。例子：
   location /foo {
        set $diff ''; # we have to predefine the $diff variable here
 
        set_by_lua $sum '
            local a = 32
            local b = 56
 
            ngx.var.diff = a - b;  -- write to $diff directly
            return a + b;          -- return the $sum value normally
        ';
 
        echo "sum = $sum, diff = $diff";
    }
    
你可以自由混用  HttpRewriteModule, HttpSetMiscModule, and HttpArrayVarModule   模块的所有指令 
    set $foo 32;
    set_by_lua $bar 'tonumber(ngx.var.foo) + 1';
    set $baz "bar: $bar";  # $baz == "bar: 33"
这个模块需要 ngx_devel_kit 模块





set_by_lua_file
syntax: set_by_lua_file $res <path-to-lua-script-file> [$arg1 $arg2 ...]
context: server, server if, location, location if
phase: server-rewrite, rewrite
说明：
和set_by_lua差不多,除了使用<path-to-lua-script-file> 包含的lua代码
 <path-to-lua-script-file> 支持nginx字符串变量参数，但要特别注意注入攻击
使用 -p  启动nginx服务器， 类似foo/bar.lua  这样的相对路径 会转为绝对路径
当lua代码缓存开启的时候，用户的代码只会在第一次请求的时候加载并缓存，当lua源代码修改的时候，nginx的配置文件每一次都必须重新加载
所以当你调试lua代码的时候最好把lua_code_cache 关掉
这个指令需要 ngx_devel_kit 模块



content_by_lua
syntax: content_by_lua <lua-script-str>
context: location, location if
phase: content
说明：
类似内容处理，每一次请求的时候都会执行<lua-script-str>的代码，
这个lua代码可以用 API调用，，执行的上时候每一次都会在全局环境下催生新的协程
不要在同一个location中和其他的内容处理一起使用这个指令。比如这个指令不能和 proxy_pass 指令在同一个location使用




content_by_lua_file
syntax: content_by_lua_file <path-to-lua-script-file>
context: location, location if
phase: content
说明：
和content_by_lua差不多,除了使用<path-to-lua-script-file> 包含的lua代码
nginx变量在 <path-to-lua-script-file> 中使用，让他能更灵活。但是这个带有一定的风险，一般不推荐使用





rewrite_by_lua
syntax: rewrite_by_lua <lua-script-str>
context: http, server, location, location if
phase: rewrite tail
做为每一次请求都重写阶段处理程序和在 <lua-script-str>执行lua代码，在lua代码中可以使用api调用，可以在独立的全局环境中催生新的协程
备注，这个通常是运行在 HttpRewriteModule模块之后，例子：
location /foo {
     set $a 12; # create and initialize $a
     set $b ""; # create and initialize $b
     rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
     echo "res = $b";
 }
因为在rewrite_by_lua之前设置了$a和$b，所以正常运行

以下例子运行结果和预期的不一样：
 location /foo {
          set $a 12; # create and initialize $a
          set $b ''; # create and initialize $b
          rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
          if ($b = '13') {
             rewrite ^ /bar redirect;
             break;
          }
    
          echo "res = $b";
      }
因为是在 rewrite_by_lua 之后。
正确的写法应该全写在 rewrite_by_lua里，例子：
set $a '12';
set $b '';
rewrite_by_lua '
    ngx.var.b = tonumber(ngx.var.a)+1
    if tonumber(ngx.var.b)==13 then
        return ngx.redirect("/bar")
    end
'; 
echo "res=$b";


ngx_eval 模块和rewrite_by_lua模块近似，例子：
 location / {
        eval $res {
            proxy_pass http://foo.com/check-spam;
        }
 
        if ($res = 'spam') {
            rewrite ^ /terms-of-use.html redirect;
        }
 
        fastcgi_pass ...;
    }
    
 用ngx_lua实现：
   location = /check-spam {
        internal;
        proxy_pass http://foo.com/check-spam;
    }
 
    location / {
        rewrite_by_lua '
            local res = ngx.location.capture("/check-spam")
            if res.body == "spam" then
                return ngx.redirect("/terms-of-use.html")
            end
        ';
 
        fastcgi_pass ...;
    }


就像其他重写处理程序， rewrite_by_lua 也运行子请求
备注，当在 rewrite_by_lua 内调用ngx.exit(ngx.OK)，nginx请求处理控制流程将会继续处理内容。
在rewrite_by_lua内终止请求，调用 ngx.exit 将会在成功的时候返回 status >= 200 (ngx.HTTP_OK) 到status < 300 (ngx.HTTP_SPECIAL_RESPONSE) 之间
失败的时候会ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) (or its friends) 


如果HttpRewriteModule的rewrite指令用来修改URI和 在location重新查找， 在location里的任何 rewrite_by_lua 或 rewrite_by_lua_file都不会运行，例子：
location /foo {
        rewrite ^ /bar;
        rewrite_by_lua 'ngx.exit(503)';
}
location /bar {
  ...
}
在这里， ngx.exit(503) 将永远不会运行. 这是在 如果rewrite ^ /bar 是最后使用，进行内部重定向的情况下。
如果改用break这个就不会进行内部重定向，rewrite_by_lua的代码会执行
rewrite_by_lua通常是用在请求处理的最后重写，至少在 rewrite_by_lua_no_postpone 开启的时候是这样



rewrite_by_lua_file
syntax: rewrite_by_lua_file <path-to-lua-script-file>
context: http, server, location, location if
phase: rewrite tail












